\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{{figures/}}  % then \includegraphics{createmode_0.jpg}
% for color box
\usepackage{tcolorbox}
\tcbuselibrary{listings, skins, breakable}
% math
\usepackage{amsmath, amssymb, amsthm}
% for float formatting options
\usepackage{float}
% tikz
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, fit}
% for tikz formatting
\usepackage{adjustbox}
% for links
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=magenta,
citecolor=violet]{hyperref}
% for glossary
\usepackage[nonumberlist]{glossaries}
\makeglossaries
% for table
\usepackage{booktabs}
\usepackage{tabularx}
% for fancy verbtim
\usepackage{fancyvrb}

\title{Vulkan Notes}
\author{Joseph Grimsic}
\date{November 2025}
\usepackage[letterpaper, top=1.3in, bottom=1.3in, left=1.3in,
right=1.3in, heightrounded]{geometry}
\renewcommand{\baselinestretch}{1.15} % Line spacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.8em}
\begin{document}
\maketitle

% --- This is the magic command --- // idk why this is important for-
% table of contents?
\tableofcontents

\newpage % Starts the main content on a new page

\section*{Vulkan Questions}
\addcontentsline{toc}{section}{Vulkan Questions}
\begin{itemize}
  \item tmp
\end{itemize}

\section*{What If I Use Sascha as a starting point}
\addcontentsline{toc}{section}{What If I Use Sascha as a starting point}
\begin{itemize}
  \item How would I work with or change this program to write a game engine?
  \item What abstractions would I want to make?
  \item What if I am a solo dev—does that change how I should abstract things?
  \item How can I black box the lesser parts of Vulkan I don't need
    to know that deeply?
  \item What levels of abstraction will I usually be using?
\end{itemize}

\section*{Vulkan Resources}
\addcontentsline{toc}{section}{Vulkan Resources}
\begin{itemize}
  \item
    \href{https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp}{Vulkan
    Triangle Example}
  \item \href{https://github.com/KhronosGroup/Vulkan-Hpp}{Vulkan Helper?}

  \item
    \href{https://www.reddit.com/r/GraphicsProgramming/comments/tc9d2u/the_current_state_of_gpu_apis_and_why_i_wish_vez/}{Interesting
    opinions on Vulkan}

  \item
    \href{https://docs.vulkan.org/tutorial/latest/00_Introduction.html}{Vulkan
    Tutorial By Khronos Group}
  \item \href{https://vkguide.dev/}{vkguide.dev}
  \item
    \href{https://www.youtube.com/watch?v=2NVlG9TFT1c&t=202s}{YouTube
    Video With Great Diagrams}
\end{itemize}

% END RESOURCES

\section*{Sascha Willems Helpers}
\addcontentsline{toc}{section}{Sascha Willems Helpers}
\subsection*{\_CreateInfo and \_Info}
\addcontentsline{toc}{subsection}{\_CreateInfo and \_Info}
I don't know what Sascha's functions are entirely for\textemdash
except that they attempt to reduce Vulkan boilerplate. However, it
seems that every function returns two kinds of pointers:
\begin{verbatim}
*_CreateInfo
*_Info
\end{verbatim}
\par We are using some kind of struct\textemdash but I'm not sure what the
struct is for. The struct probably holds whatever these two kinds of
pointers point to?

\par So actually, the \* in \*\_CreateInfo and
\*\_Info represent the wildcard operator, and is just to show
the naming convention in the documentation. These names refer to
structs that have state information for Vulkan.

\subsection*{Sascha Willems Helpers: CreateInfo vs Info}
\addcontentsline{toc}{section}{Sascha Willems Helpers (Gemini)}
I noticed that Sascha’s helper functions—which are designed to reduce
Vulkan boilerplate—constantly utilize two specific naming
conventions. These are not just random names; they correspond to the
specific Vulkan structures we use to pass data to the driver.

The asterisk (*) in the names below acts as a wildcard for the
specific object name:
\begin{itemize}
  \item \textbf{\_CreateInfo} (e.g., \texttt{VkDeviceCreateInfo}):
    These structs are used during the \textbf{Object Creation} phase.
    They are the "forms" we fill out to tell the driver how to build
    a persistent object. They always contain \texttt{sType} and \texttt{pNext}.
  \item \textbf{\_Info} (e.g., \texttt{VkSubmitInfo}): These structs
    are generally used inside the \textbf{Render Loop}. They pass
    temporary state or parameters for a specific action, like
    submitting a draw call. These also utilize \texttt{sType} and
    \texttt{pNext}.
\end{itemize}
Sascha's helper functions simply automate the process of filling out
these structs so we don't have to manually set every field (like
\texttt{sType}) every time.

\section*{Sascha Repository Notes}
\addcontentsline{toc}{section}{Sascha Repository Notes}
\par Git does not automatically download submodules

\par To update submodules:
\begin{verbatim}
git submodule update --init --recursive
\end{verbatim}

\par The following is an example clean build script specific to Wayland:

\begin{verbatim}
#!/usr/bin/env bash
set -e

BUILD_DIR="build"

echo ">>> Removing old build directory..."
rm -rf "$BUILD_DIR"

echo ">>> Creating new build directory..."
mkdir "$BUILD_DIR"
cd "$BUILD_DIR"

echo ">>> Running CMake configure..."
cmake .. \
  -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
  -DUSE_WAYLAND_WSI=OFF

echo ">>> Building..."
cmake --build . -- -j"$(nproc)"

# Optionally copy compile_commands.json to project root
if [ -f compile_commands.json ]; then
    echo ">>> Copying compile_commands.json to project root..."
    cp compile_commands.json ..
fi

echo ">>> Done."
\end{verbatim}

Then you can run the binaries, for example:
\begin{verbatim}
./build/bin/bloom
\end{verbatim}

\section*{Reading Through The Vulkan Tutorial}
\addcontentsline{toc}{section}{Reading Through The Vulkan Tutorial}
Here is a high level of how I would currently describe the Vulkan setup:

\begin{enumerate}
  \item create instance
  \item device selection
  \item create window
  \item then some other stuff
\end{enumerate}

here is my second attempt at that
\begin{enumerate}
  \item create instance + device selection
  \item queue families stuff
  \item create window + swapchain
  \item framebuffer stuff
  \item probably something else
\end{enumerate}

\par we are getting closer, but honestly maybe it's not that important. i
am considering reading throught the Vulkan tutorial but i am unsure
as when to just jump in. i could probably save some time in the
future by reading a little bit now but i suspect i will not retain
that much information. i guess i will take some notes.
\par first i will skip to the hello triangle in their example and think of
some questions i have..
\par some things that stand out to me:
\begin{itemize}
  \item item (will i finish?)
\end{itemize}

\section*{Going Through Sascha's Repository}
\addcontentsline{toc}{section}{Going Through Sascha's Repository}
\subsection*{Idea}
\addcontentsline{toc}{subsection}{Idea}
I am thinking this will be faster to learn as Sascha provides a
standard hello triangle program (meant to be as vanilla as possible)
and shows his evolution (you can see comments in his READ.md) of
abstractions. This will likely make the most sense to study because
we know that Sascha has a
\href{https://github.com/SaschaWillems/Vulkan?tab=readme-ov-file}{very
popular repo} so we can assume others think it is good and that it is
a valid idea for me to pursue.

\subsection*{Notes On Sascha}
\addcontentsline{toc}{subsection}{Notes On Sascha}
\par Let's start with is Sascha's claimed vanilla hello triangle similar
to the one in the Khronos Vulkan tutorial?

\subsection*{Questions From Sascha's Repo:}
\addcontentsline{toc}{subsection}{Questions From Sascha's Repo:}
\begin{itemize}
    % \item what is a descriptor set in vulkan?
  \item what is the graphics queue?
    % \item what is a vk semaphore?
    % \item what is vk device?
    % \item what is vk null handle?
    % \item what is vk descriptor set?
  \item what is vk pipeline layout?
  \item how to read/write to a glm::mat4?
    % \item what is vk descriptor set layout?
  \item how do we interact with vk command pool?
  \item what does this do?
  \begin{verbatim}
  VulkanExample() : VulkanExampleBase() {
  \end{verbatim}

\end{itemize}

\section*{Theory}
\addcontentsline{toc}{section}{Theory}
\subsection*{Descriptor Set}
\addcontentsline{toc}{subsection}{Descriptor Set}
\par Descriptor sets are sets of pointers to resources that shaders
want access to. In OpenGL, you might 'bind' one buffer at a time.
Vulkan expects you to bind a descriptor set all together.
\par Similar to \textbf{command pools} there are \textbf{descriptor pools}.

\subsection*{Descriptor Set Revised}
\addcontentsline{toc}{subsection}{Descriptor Set Revised}
\par Coming back to the \textbf{descriptor set}, I am considering
constraints. For example, why not just have one big descriptor set,
to solve the problem of not understanding how to separate data into
different descriptor sets.

\par Then of course, if that doesn't work, why
not generate a new descriptor set each frame if duplicating the
massive single descriptor set is expensive.

\par I don't know yet, but the following is a table showing how we
typically use 4 descriptor sets simultaneously.

\begin{table}[h]
  \centering
  \caption{Descriptor Set Layout Configuration}
  \label{tab:descriptor_sets}
  \begin{tabularx}{\textwidth}{@{}lllX@{}}
    \toprule
    \textbf{Set} & \textbf{Frequency} & \textbf{Data Name} &
    \textbf{Description} \\
    \midrule
    Set 0 & Global & Frame Data & Camera View/Projection matrices,
    Global Time, Skybox. (Bound once per frame) \\
    Set 1 & Per-Pass & Pass Data & Shadow maps, Light lists,
    Post-processing buffers. (Bound once per render pass) \\
    Set 2 & Per-Material & Material Data & Albedo texture, Normal
    map, Roughness value. (Bound when material changes) \\
    Set 3 & Per-Object & Object Data & Model Matrix (transform),
    skinning bones. (Bound for every draw call) \\
    \bottomrule
  \end{tabularx}
\end{table}

\subsection*{Descriptor Pools}
\addcontentsline{toc}{subsection}{Descriptor Pools}
\par To allocate a descriptor set, we first intialize a descriptor
pool. When setting up a descriptor pool, we tell Vulkan there will be
'x' number of sets with 'y' number of descriptors

\subsection*{Fences}
\addcontentsline{toc}{subsection}{Fences}
\par A fence is used to sync the CPU and GPU. I don't know how it
does this. A fence can be \textbf{signaled} by the GPU, so that the
CPU knows that the GPU has finished drawing the frame.

\subsection*{Semaphore}
\addcontentsline{toc}{subsection}{Semaphore}
\par Similarly, a \textbf{semaphore} is used to sync different parts
of the GPU. Some examples of semaphores are:
\begin{itemize}
  \item \textbf{renderSemaphore}
  \item \textbf{swapchainSemaphore}
\end{itemize}
\par There is also a \textbf{complete semaphore}, but I don't know
what that is for yet.

\subsection*{Projection Matrix}
\addcontentsline{toc}{subsection}{Projection Matrix}
\par This has something to do with how objects look when they are
further away, maybe it does some multiplication on the location of
the vertices on screen coordinates?

\par This is close. It has to do with a matrix multiplication on the
3d vertices of an object, altering how it looks from far away. The
projection matrix is part of the pipeline to get objects in 3d space
to screen space coordinates.

\par Note: The lack of a projection matrix is called an orthographic projection.

\subsection*{View Model Matrix}
\addcontentsline{toc}{subsection}{View Model Matrix}
\par This has something to do with the view frustum? Perhaps this is
the matrix that we perform operations on to change the camera
position and angle?

\subsection*{Depth Stencil Image}
\addcontentsline{toc}{subsection}{Depth Stencil Image}
\par What is the depth stencil image? I mean stencils are like
outlines of stuff so maybe depth stencil image draws the outlines of
objects in the depth frame buffer? Is the Z buffer a separate frame buffer?

\par So a depth stencil image is actually a combination of buffers
(both the depth and stencil buffers).

\subsection*{Stencil Buffer}
\addcontentsline{toc}{subsection}{Stencil Buffer}
\par Let's review what a stencil buffer is. It is true that a stencil
buffer can be used for outlines, but more generally\textemdash
stencil buffers can be thought of as masks. The concept of masking is
where you can think of separating layers. So you may 'cutout' a layer
by masking, so that you can see to the next layer.

\par Another way to think of this as a subtractive process. Here is
an excerpt from a conversation with Gemini 2.5 Pro:
\begin{verbatim}
Pass 1: Draw the Object (to create the "cutout" mask).
        Turn off writing to the color and depth buffers.
        Turn on writing to the stencil buffer.
        Set the stencil operation to: "If a pixel passes the depth test,
        write the value 1 into the stencil buffer."
        Draw your mesh.

        Result: The screen looks unchanged, but the stencil buffer now
        contains a perfect silhouette (a "mask") of your object, filled
        with the number 1. Everything else is 0.

    Pass 2: Draw the Outline (the "big yellow" version).
        Turn on writing to the color buffer (so we can see the yellow).
        Turn off writing to the depth buffer (this prevents the outline
        from messing up future depth tests).
        Set the stencil test to: "Only draw a pixel if the stencil buffer value
        at that location is NOT 1 (i.e., it's 0)."
        Draw a slightly larger version of your mesh, all in yellow.

    The "Cutout" Happens:

        The GPU starts to draw the big yellow mesh.
        Where the original object was (the "inner layer"), the stencil buffer
        has a 1. The test (stencil_value != 1) fails, and the yellow pixel is
        discarded. This is your "cutout"!

        On the larger edges of the yellow mesh (the "thickness" you mentioned), the pixel falls outside the original silhouette. The stencil buffer there is 0. The test (stencil_value == 0) passes, and the yellow pixel is drawn.

Final Result: You are left with only the yellow outline.
\end{verbatim}

\subsection*{Reading Code Snippet And Some Resulting Questions}
\addcontentsline{toc}{subsection}{Reading Code Snippet And Some
Resulting Questions}

\par When reading through Sascha's examples I came across this segment from
triangle.cpp:

\begin{verbatim}
// Create a view for the depth stencil image
// Images aren't directly accessed in Vulkan, but rather through views
// described by a subresource range This allows for multiple views of one
// image with differing ranges (e.g. for different layers)
VkImageViewCreateInfo depthStencilViewCI{};
depthStencilViewCI.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
depthStencilViewCI.viewType = VK_IMAGE_VIEW_TYPE_2D;
depthStencilViewCI.format = depthFormat;
depthStencilViewCI.subresourceRange = {};
depthStencilViewCI.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
\end{verbatim}

\par What is a view? It seems that we first initialize the view and
then there are several instance variables we set for it. This code
snippet reveals many different questions:
\begin{itemize}
  \item What is a \textbf{subresource}?
  \item What is an \textbf{aspect}?
  \item What what does '\textbf{CI}' mean in 'depthStencilViewCI'?
\end{itemize}

\par I also have some more questions as a result from this snippet:
\begin{itemize}
  \item What kinds of things do we need a view for?
  \item Does Sascha abstract some of this 'state stuff' away when
    intializing a view?
  \item What does an all caps variable like
    'VK\_STRUCTURE\_TYPE\_IMAGE\_VIEW\_CREATE\_INFO'| mean again? Is it a
    global constant?
  \item \textemdash and finally, how much of this is important to me
    as an engine developer?
\end{itemize}

\subsection*{What Does 'CI' Suffix Mean In Variable Names?}
\addcontentsline{toc}{subsection}{What Does 'CI' Suffix Mean In Variable Names?}
\par CI is actually shorthand for \textbf{Create Info}. This is
because this variable is a \textbf{CreateInfo struct}, same as we
mentioned earlier.

\subsection*{VK View}
\addcontentsline{toc}{subsection}{VK View}
\par Images cannot be directly accessed in Vulkan, but instead with a
View object. Hence the two Vulkan objects:
\begin{itemize}
  \item VkImage
  \item VkImageView
\end{itemize}

\subsection*{How Does A View Relate To A Frame Buffer?}
\addcontentsline{toc}{subsection}{How Does A View Relate To A Frame Buffer?}
\par A frame buffer has views as attachments?

\par A \textbf{VkImage} is a collection of the image's raw data and
overall properties such as:
\begin{itemize}
  \item Dimension
  \item Format
  \item Mip Levels
\end{itemize}

\subsection*{Subresource}
\addcontentsline{toc}{subsection}{Subresource}
\par What is a subresource and how can it have a range?

\subsection*{VK\_NULL\_HANDLE}
\addcontentsline{toc}{subsection}{VK\_NULL\_HANDLE}
\par Weirdly, the VK\_NULL\_HANDLE is an integer, and not a null
pointer or something like that. We use VK\_NULL\_HANDLE| when we
are declaring some Vulkan object without giving it a value.

\subsection*{Ticket Number}
\addcontentsline{toc}{subsection}{Ticket Number}
What is a \textbf{ticket number}? What does it mean if there is an
\textbf{empty ticket number}? What is a \textbf{ticket slot}, and
what does it mean for it to be empty (0)?

\subsection*{How is initialization abstracted with Sascha's Framework?}
\addcontentsline{toc}{subsection}{How is initialization abstracted
with Sascha's Framework?}

\par The following is a snippet from a conversation with Gemini 2.5 Pro:
\begin{verbatim}
Before: Raw Vulkan (What we discussed)

You have to manually zero-initialize every struct and set every single
member, including the sType.

// 1. Define the binding
VkDescriptorSetLayoutBinding uboBinding{};
uboBinding.sType = ... // Easy to forget! Oh wait, this one doesn't have sType.
uboBinding.binding = 0;
uboBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
uboBinding.descriptorCount = 1;
uboBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
uboBinding.pImmutableSamplers = nullptr;

// 2. Define the create info
VkDescriptorSetLayoutCreateInfo layoutInfo{};
layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
layoutInfo.pNext = nullptr;
layoutInfo.flags = 0;
layoutInfo.bindingCount = 1;
layoutInfo.pBindings = &uboBinding;

After: With Sascha Willems' vks::initializers

He provides helper functions that act as "constructors" for these C structs.
They take the important parameters and set all the other members (sType, pNext,
flags, etc.) to correct default values.

// 1. Define the binding (one line)
VkDescriptorSetLayoutBinding uboBinding =
    vks::initializers::descriptorSetLayoutBinding(
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        VK_SHADER_STAGE_VERTEX_BIT,
        0); // type, stage, binding

// 2. Define the create info (one line)
VkDescriptorSetLayoutCreateInfo layoutInfo =
    vks::initializers::descriptorSetLayoutCreateInfo(
        &uboBinding,
        1); // pBindings, bindingCount
\end{verbatim}
This example may prove useful when learning Sascha's framework.

\subsection*{What is multisampling (MSAA?)}
\addcontentsline{toc}{subsection}{What is multisampling (MSAA?)}
\par Multisampling (MSAA) is a method of anti aliasing. Aliasing happens
when a single sample inside of the pixel does not detect the
sub\-pixel fragment, so the result of the pixel can become an
artifact. Sub\-pixel artifacting are called \textbf{jaggies}, which
are a result of aliasing. To address this issue, we have multiple
sub\-pixel samples\textemdash hence the name.

\subsection*{Device vs. Physical Device}
\addcontentsline{toc}{subsection}{Device vs. Physical Device}
\par In Vulkan, there are two kinds of devices:
\begin{itemize}
  \item The \textbf{physical device (VkPhysicalDevice)}
  \item And the \textbf{logical device (VkDevice)}
\end{itemize}
\par Most always in the context of Vulkan, we are talking about the
logical device. The logical device is the object that you use to
interface with the hardware. You initialize VkDevice with the
tools/features that you are going to be using from the GPU.

% Begin large gemini latex segment
\subsection*{High-level pseudocode: Basic indexed triangle (Vulkan 1.3)}
\addcontentsline{toc}{subsection}{High-level pseudocode: Basic
indexed triangle (Vulkan 1.3)}

This example initializes a minimal Vulkan application that renders a
single indexed triangle using Vulkan 1.3 dynamic rendering and
per-frame uniform buffers.

\begin{enumerate}
  \item Create the application object and parse command-line
    arguments. Configure a simple look-at camera and request Vulkan
    API version \texttt{VK\_API\_VERSION\_1\_3}, enabling the
    \texttt{dynamicRendering} and \texttt{synchronization2} features.
  \item Initialize Vulkan: create an instance, select a compatible
    physical device, create a logical device and graphics queue, and
    cache device properties and memory capabilities for later allocations.
  \item Prepare global state and resources used across frames:
    determine swapchain color/depth formats and reserve per-frame
    arrays sized by \texttt{MAX\_CONCURRENT\_FRAMES} for in-flight resources.
  \item Create synchronization primitives: one fence per in-flight
    frame (initially signaled) and semaphores to coordinate image
    acquisition and render completion.
  \item Create one command pool and allocate one primary command
    buffer per in-flight frame.
  \item Build vertex and index data for a triangle; compute buffer
    sizes and the index count.
  \item Create a host-visible staging buffer, map it, and copy both
    vertex and index data into that single mapped region.
  \item Create device-local vertex and index buffers (with transfer
    destination usage), allocate device-local memory for each, and bind them.
  \item Record and submit a short command buffer that copies the
    ranges from the staging buffer into the device-local buffers; use
    a temporary fence to wait for completion, then free the staging buffer.
  \item Define a uniform block type containing projection, view and
    model matrices and create one host-visible, coherent uniform
    buffer per in-flight frame; map them persistently for fast updates.
  \item Create a descriptor pool and a descriptor set layout for a
    single uniform buffer binding; allocate and update one descriptor
    set per in-flight frame to point at the corresponding uniform buffer.
  \item Create a pipeline layout using the descriptor set layout,
    then build the graphics pipeline: load SPIR-V shaders, configure
    vertex input bindings/attributes, input assembly, rasterization,
    depth/stencil, multisampling, color blend and dynamic
    viewport/scissor, and attach dynamic rendering formats.
  \item Allocate and bind a device-local depth image and create an
    image view for depth/stencil usage.
  \item In the render loop: wait on the current frame fence, acquire
    the next swapchain image (handling out-of-date/suboptimal by
    resizing), update the mapped uniform buffer for the current
    frame, reset and begin the command buffer.
  \item Insert image memory barriers to transition color and depth
    images to attachment-optimal layouts, begin a dynamic rendering
    section, set viewport and scissor dynamically, bind pipeline and
    the current frame's descriptor set, bind vertex and index
    buffers, and issue a single indexed draw call; end rendering and
    transition the color image to present layout.
  \item Submit the command buffer waiting on the present semaphore
    and signaling a render-complete semaphore; pass the per-frame
    fence for GPU completion tracking. Present the image using
    \texttt{vkQueuePresentKHR}, handling resizing if necessary, and
    advance the current frame index modulo \texttt{MAX\_CONCURRENT\_FRAMES}.
  \item On shutdown, wait for device idle and clean up: destroy
    pipelines, pipeline layout, descriptor set layout and pool,
    buffers and their memories, image views and images, semaphores,
    fences, command pool and swapchain resources; delete the application object.
\end{enumerate}

\par \textbf{One thing to note}:

\par After looking at the example \textbf{Raytracing Reflections}, I
noticed that there are only 500 lines of code, and the output is a
fully rendered scene with some reflections. This sort of thing gives
me hope because the complexity was seeming cut in half (compared to
900 lines for a triangle). This seems like a decent starting point
for a scene. There are still lots of points of confusion\textemdash
even some that are purely about C++ for example the \textbf{::}
operator not only being used for namespaces.
% End large gemini latex segment

\subsection*{Families and
Queues}\addcontentsline{toc}{subsection}{Families and Queues}

\par When a Vulkan instance is created, one of the things it does
before anything is rendered to the screen, is query the system's GPU
(vkPhysicalDevice). The physical device will tell us important
information; for example, the index of the compute family. This is
because different GPU's have different index values for families.

\paragraph*{Families}\addcontentsline{toc}{paragraph}{Families}

A family is a group of \textbf{queues}. For example, there is the
\textbf{graphics family}, which has one or more \textbf{graphics
queue} objects that interface with the rendering hardware.

\paragraph*{Graphics Queue}\addcontentsline{toc}{paragraph}{Graphics Queue}

The \textbf{graphics queue} is an object that you would send commands
to. The graphics queue is responsible for the rendering, as opposed
to the \textbf{compute queue}, which you might use for gameplay math.

\paragraph*{Compute Queue}\addcontentsline{toc}{paragraph}{Compute Queue}

But actually it is not just for 'gameplay math', but instead highly
parallelizable math. Some examples are the folllwing:
\begin{itemize}
  \item Physics Simulations
  \item Post Processing (Not apart of the graphics queue!?!)
  \item Culling!?
\end{itemize}

\paragraph*{Transfer Queue}\addcontentsline{toc}{paragraph}{Transfer Queue}

\paragraph*{Transfer Queue}
The \textbf{transfer queue} is specialized for high-speed DMA (Direct
Memory Access) transfers. We use this queue to move data from
CPU-visible \textbf{staging buffers} into high-performance GPU
memory. This includes bulk data such as textures, vertex buffers, and
index buffers. By offloading these copy operations to the transfer
queue, the graphics queue remains free to focus entirely on
rendering, allowing for asynchronous execution.

\paragraph*{What Are Queues
For?}\addcontentsline{toc}{paragraph}{What Are Queues For?}

Queues are objects that receive \textbf{commands}. The central idea behind
Vulkan is that the GPU receives \textbf{command buffers} from the CPU
program, and the GPU (physical device) executes said commands.

\paragraph*{Why Not Submit All Tasks To One Of The
Families?}\addcontentsline{toc}{paragraph}{Why Not Submit All Tasks
To One Of The Families?}

We seperate graphics family tasks and compute family tasks because
say we were to put everything on the graphics queue; then, we would
not be able to compute our graphics tasks in parallel with our compute tasks.

\subsection*{Slang}\addcontentsline{toc}{subsection}{Slang}

\par After looking at a Slang shader file, I notice things like there
are global functions for dot() and sqrt(). What other global
functions are there? What are some main concepts behind writing shaders?

\par Here is an example of collision detection in Slang:
\begin{verbatim}
    // collide with boundary
    if ((vPos.x < -1.0) || (vPos.x > 1.0) || (vPos.y < -1.0) || (vPos.y > 1.0)) {
        vVel = (-vVel * 0.1) + attraction(vPos, destPos) * 12;
    } else {
        particlesOut[index].pos.xy = vPos;
    }
\end{verbatim}

\par What is this following segment for?
\begin{verbatim}
    // Write back
    particlesOut[index].vel.xy = vVel;
    particlesOut[index].gradientPos.x = gPos.x + 0.02 * ubo.deltaT;
    if (particlesOut[index].gradientPos.x > 1.0) {
        particlesOut[index].gradientPos.x -= 1.0;
    }
\end{verbatim}

\subsection*{sType + pNext}\addcontentsline{toc}{subsection}{sType + pNext}
\par sType and pNext are both core concepts in Vulkan. Vulkan is
close to the hardware, and thus it is directly talking to your GPU's
drivers. Your GPU drivers do not know how to get to the memory that
you want them to.

\par Enter: the Vulkan linked-list structure. Vulkan keeps an
important linked list, which you can add to by setting pNext.
However, your driver also needs to know what pNext is pointing to (it
is a void* after all). \textbf{sType} (short for struct type) tells
the drivers what the struct is.

\par This Vulkan linked-list structure we are talking about is the
\textbf{extension chain}. Why is the extension chain important?

\par So the extension chain (the idea that requires pNext and sType)
is used once at setup, and then becomes obsolete. In other words: it
sets parameters at the beginning of the program. This is called the
\textbf{object creation} phase.

\par However, there is an \textit{exception} to this. Every time we
record a command buffer (every frame) we require pNext and sType. Why?

\subsection*{sType + pNext (as described by gemini
3)}\addcontentsline{toc}{subsection}{sType + pNext (gemini)} \par
sType and pNext are
both core concepts in Vulkan. Vulkan is close to the hardware, and
thus it is directly talking to your GPU's drivers.

\par The Problem: When you pass a generic pointer to the driver, the
driver can access that memory, but it doesn't know how to interpret
it. It doesn't know if the data at that address is a request to
create a buffer, an image, or a device.

\par The Solution: The Vulkan extension chain. Vulkan allows you to
build a linked list by setting \textbf{pNext}. To help the driver
understand what it is looking at, \textbf{sType} (Structure Type)
acts as an ID tag. It tells the driver exactly what struct type is
sitting at that memory address.

\par This structure is primarily used in the Object Creation phase.
You build the chain to set parameters, pass it to the driver to
create an object (like a Device), and then the chain is obsolete.

\par However, we also encounter sType and pNext in the Render Loop.
When recording command buffers each frame, we fill out temporary
structures to describe the current frame's work. Just like in setup,
the driver reads these structures once to translate them into GPU commands.

\subsection*{vkPipelineLayout}\addcontentsline{toc}{subsection}{vkPipelineLayout}
\par What is a vkPipelineLayout?

\subsection*{Commands}
\addcontentsline{toc}{subsection}{Commands}
\par Commands are the main part of Vulkan. Commands are how we talk
directly to the GPU.

\par Commands are normally stored in a \textbf{command buffer}, so we
can batch them together. We usually call the act of intializing a
command buffer \textbf{recording} the command buffer. In the Vulkan
workflow, we will have record a command buffer using a
\textbf{command pool}. We will have one command pool for every
\textbf{queue family}.

\par Note: I wrote this a while ago but just recently move it to this
section of the doc

\subsection*{How Do We Allocate A Staging
Buffer?}\addcontentsline{toc}{subsection}{How Do We Allocate A Staging Buffer?}
\par So you want to send memory to the GPU yeah? Well you're going to
need a \textbf{staging buffer}.

\par To allocate a staging buffer, we will use the vk object
\textbf{vks::vkBuffer}. Is the vks namespace special to Sascha
Willems' helper functionality?

\par Does a staging buffer go straight to
the GPU? How is the transfer queue involved? Are there more than one
staging buffer?

\par Below is a snippet of buffer staging logic:
\begin{Verbatim}[fontsize=\footnotesize]
for (auto &storageBuffer : storageBuffers) {
  // The SSBO will be used as a storage buffer for the compute pipeline and as a vertex buffer in the graphics pipeline
  vulkanDevice->createBuffer(VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
                                 VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                             VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &storageBuffer, storageBufferSize);
\end{Verbatim}

\subsection*{Event Queue}\addcontentsline{toc}{subsection}{Event Queue}
\par Do I want to implement this? Would a physics-based platformer
want an event queue? What are they used for? I feel like they would
be used for stories or something, but that case would require some
check before the next event can happen.

\par Actually an event queue is used to \textbf{decouple} an initial
event and a reactionary event (What is decoupling?). You can think of
it as storing a message for something that has happened, so that we
can use that information later.

% END VULKAN
\clearpage

\section*{C++ Notes}
\addcontentsline{toc}{section}{C++ Notes}

\subsection*{Struct vs. Class}
\addcontentsline{toc}{subsection}{Struct vs. Class}
\par One thing that vkguide.dev has brought to my attention is when
to use struct versus when to use a class. From my understanding, a
struct is used for simple instances when we just need to store a
group of data. A class can hold lots of things for example state,
functionality, and data too.

\subsection*{Constructor Definition Syntax}
\addcontentsline{toc}{subsection}{Constructor Definition Syntax}
\par The following is a way to declare a new constructor:

\begin{verbatim}
VulkanExample() : VulkanExampleBase() {}
\end{verbatim}

\par More generally, it is written as:
\begin{verbatim}
constructorFromDerivedClass?() : NewConstructor?()
\end{verbatim}

\par I am very confused\textemdash but maybe it is unimportant

\subsection*{How To Make A Class}
\addcontentsline{toc}{subsection}{How To Make A Class}
\par In C++, to make a class we usually do the following:
\begin{enumerate}
  \item Declare the class in a header (e.g. class.h)
  \item Implement the class functionality in a source file (e.g. class.cpp)
\end{enumerate}

\subsection*{How To Make A Struct}
\par Weirdly, in C++ structs do not need keyword \textbf{typedef}
when declared..

\subsection*{How To Make A Template Class?}
\addcontentsline{toc}{subsection}{How To Make A Template Class?}
\par A template has to do with implementing functionality across
different primitive types? Like overloading function sum so that
sum(int a, int b) and sum(double a, double b)? What makes templates
different than classes? Do we use headers for them too?

\subsection*{:: Operator}
\addcontentsline{toc}{subsection}{:: Operator}
\par I was previously aware that the \textbf{::} operator could be
used to access members of a namespace\textemdash but now I am finding
out that it can be used to call specific functions in an inheritance
hierarchy. How does this work?

\par Update: The \textbf{::} operator is called the \textbf{scope
resolution modifier}. The scope resolution modifier is not only used
for namespace members, but another example is an enum class. Say you
have an enum class defined with the following:
\begin{verbatim}
enum class ShadowQuality{
kNone,
kLow,
kMedium,
kHigh,
}
\end{verbatim}

\subsection*{Const Correctness}
\par I don't fully understand the idea of \textbf{const
correctness}\textemdash but so far it seems like the idea of a
read-only member variable. The current working example I am
considering is the following:

\par We want our game engine to allow the user to choose settings
based on the power of their machine. For example, the user may want
to lower quality of shadows, so we can set shadows to the following states:
\begin{itemize}
  \item High Quality
  \item Medium Quality
  \item Low Quality
  \item None
\end{itemize}

\par We can store this data in a struct:
\begin{verbatim}
struct {
int shadow_quality
} typedef GameConfig
\end{verbatim}

\subsection*{Ternary
Operator}\addcontentsline{toc}{subsection}{Ternary Operator}
\par This one is pretty simple, the idea is that if we want to make
an if/else statement into one line, we can use the \textbf{ternary
operator}.

\par Here is an example:
\begin{verbatim}
std::default_random_engine rndEngine(benchmark.active ? 0 : (unsigned)time(nullptr));
\end{verbatim}

\par The above can be read as "If benchmark.active, then 0, else
(unsigned)time(nullptr))".

\par Side note: This code is initializing a random number generator
(RNG), and setting the seed to 0 if we are benchmarking (for determinism)

\subsection*{Destructors}\addcontentsline{toc}{subsection}{Destructors}
\par This one is going to be short for now, but it's probably
important. So obviously there are constructors, what do they do? Well
they initialize an instance of a class (does it work for objects
too?). Well what if the class allocated dynamic memory? Then this
would mean that we need to call free at some point right? Do
destructors exist so that we don't have to do this?

\subsection*{Auto}\addcontentsline{toc}{subsection}{Auto}
\par So the main idea of \textbf{auto} is that it will
\textit{automatically} determine the type of a value?

\par I'm not sure when you would want to use this, but one of the
popular ways to use this is with a \textit{for-each loop}. It helps
because if we change the tpye of the values we are iterating over,
normally we would have to go find the for-each loop in question and
change the type there too.

\subsection*{Asynchronous
Code}\addcontentsline{toc}{subsection}{Asynchronous Code}
\par What is the main purpose of asynchronous code? Asynchronous code
is important when you want events that happen at the same time, not
just from top to bottom as a program is normally executed.

\par Is this where callbacks are from? Does asynchronous code require callbacks?

\par The old way of doing things

\par The new way to implement asynchronous events is using
\textbf{coroutines}. A coroutine is?

% END CPP

\section*{What Is A Valid Starting Point For My Game Engine?}
\addcontentsline{toc}{section}{What Is A Valid Starting Point For My
Game Engine?}

\par I am currently considering the example from Sascha Willems
called \textbf{Raytracing Reflections}. I am also considering
\textbf{Compute Particles}, beause Gemini said that was the closes
thing to a vertex-based physics engine\textemdash but perhaps it is
silly to try to change a code snippet that much. Some part of me
thinks it is a good idea because I don't know how to program the
Vulkan pipeline so it would be nice to follow some guideline/snippet.

\par I suppose I could just line-by-line reference the example code
and make changes I think should occur to get me closer to what I want.

\par Aside: there has to be some sort of asynchronous functionality
in the Compute Particles example right? If not, do I need to include
a special library for asynchronous code? I should probably dedicate
an entry to asynchronous code in the C++ section of this document.

\clearpage

\glsaddall
% --- Vulkan Glossary Definitions ---

\newglossaryentry{spirv}
{
name={SPIR-V},
description={GLSL, HLSL, and Slang can all be compiled to SPIR-V,
which is passed to Vulkan program}
}
\newglossaryentry{slang}
{
name={Slang},
description={A shading language that benefits from having generics
and interfaces that glsl doesn't have}
}
\newglossaryentry{semaphore}
{
name={Semaphore},
description={Object responsible for keeping different GPU cores synced}
}
\newglossaryentry{fence}
{
name={Fence},
description={Object responsible for keeping CPU and GPU synced}
}
\newglossaryentry{virtualfunction}
{
name={Virtual Function},
description={A C++ feature relating to polymorphism and inheritance
of classes}
}
\newglossaryentry{sampling}
{
name={Sampling},
description={Query a subpixel value}
}
\newglossaryentry{aliasing}
{
name={Aliasing},
description={When \textbf{jaggies} misrepresent a pixel and cause discoloring}
}
\newglossaryentry{antialiasing}
{
name={Anti Aliasing},
description={Technique to combat \textbf{aliasing}, usually by some
special way of sampling}
}
\newglossaryentry{msaa}
{
name={Multisampling Antialiasing (MSAA)},
description={An implementation of \textbf{anti aliasing}}
}
\newglossaryentry{ssaa}
{
name={Super Sampling Antialiasing (SSAA)},
description={An implementation of \textbf{anti aliasing},
considered to be 'brute force'}
}
\newglossaryentry{sync2}
{
name={Synchronization2},
description={idk, I think it's just a feature added to Vulkan that we
can ignore}
}
\newglossaryentry{dynamicrendering}
{
name={Dynamic Rendering},
description={This is the idea of removing the 'render pass' and
  'framebuffer' objects. In other words, we move the configuration
from initialization to recording time}
}
\newglossaryentry{maxconcurrentframes}
{
name={Max Concurrent Frames},
description={Number of frames to be 'processed' simultaneously}
}
\newglossaryentry{memorybarriers}
{
name={Memory Barriers},
description={Used to make sure that one GPU core is finished
writing to memory before another core tries to read}
}
\newglossaryentry{depthimage}
{
name={Depth Image},
description={idk, does this relate to the depth buffer?}
}
\newglossaryentry{zbuffer}
{
name={Z Buffer/ Depth Buffer},
description={Used to determine if an object should be rendered
in-front of another?}
}
\newglossaryentry{attachment}
{
name={Attachment},
description={idk, i think they are apart of frame buffers?}
}
\newglossaryentry{vkqueuepresent}
{
name={Vk Queue Present KHR},
description={The command that tells the OS to display the final image}
}
\newglossaryentry{deviceidle}
{
name={Device Idle},
description={Command to pause the CPU until the GPU is finished}
}
\newglossaryentry{applicationobject}
{
name={Application Object},
description={idk}
}
\newglossaryentry{vram}
{
name={VRAM},
description={Stores memory for GPU}
}
\newglossaryentry{devicelocal}
{
name={Device-Local},
description={Memory on the VRAM}
}
\newglossaryentry{swapchain}
{
name={Swap Chain},
description={A queue of rendered images waiting to be displayed}
}
\newglossaryentry{viewport}
{
name={Viewport},
description={The rectangular part of the window that is rendered
  to. For example you could have two viewports (top and bottom), for
a split-screen multiplayer effect}
}
\newglossaryentry{inflightframe}
{
name={In-Flight Frame},
description={Idea of rendering current frame on GPU, and recording
commands for next frame to be rendered, using CPU}
}
\newglossaryentry{rasterization}
{
name={Rasterization},
description={Part in graphics pipeline when we draw?}
}
\newglossaryentry{render}
{
name={Render},
description={The final output of the graphics pipeline?}
}
\newglossaryentry{attributes}
{
name={Attributes},
description={I think attributes are when we store data in vertices}
}
\newglossaryentry{commandpools}
{
name={Command Pools},
description={Object used to allocate command buffers}
}
\newglossaryentry{ticketnumber}
{
name={Ticket Number},
description={A timeline semaphore tracks completed tasks in
  strictly increasing number/sequence. A ticket number (a positive
  integer) is a certain complete task that we might wait for until we
do something else}
}
\newglossaryentry{binarysemaphore}
{
name={Binary Semaphore (Mutex)},
description={Has two states(0 or 1), used to lock a resource, and
managed by an owner}
}
\newglossaryentry{countingsemaphore}
{
name={Counting Semaphore},
description={Allows up to $N$ threads to access a resource simultanously}
}
\newglossaryentry{timelinesemaphore}
{
name={Timeline Semaphore},
description={Normal semaphore tracks complete or not
  complete\textemdash a \textbf{timeline semaphore} tracks more than
1 complete steps in increasing order}
}
\newglossaryentry{subresource}
{
name={Subresource},
description={A part of an image\textemdash but actually there are
more applications of subresource (like what?)}
}
\newglossaryentry{descriptorset}
{
name={Descriptor Set},
description={This has to do with }
}
\newglossaryentry{descriptorpool}
{
name={Descriptor Pool},
description={Obviously some kind of object to allocate descriptors
or descriptor sets?}
}
\newglossaryentry{device}
{
name={Device},
description={Like the object that keeps track of the rendering
state of the Vulkan program?}
}
\newglossaryentry{instancedmesh}
{
name={Instanced Mesh Rendering},
description={Taking an instance/object and rendering it multiple
  times. For example a tree with many instances of leaves that have
different rotations and size (Tell the GPU: "Draw this mesh 500 times")}
}
\newglossaryentry{pointrendering}
{
name={Point Rendering},
description={idk}
}
\newglossaryentry{queuefamily}
{
name={Queue Family},
description={Can refer to Graphics Queue, Compute Queue, or
Transfer Queue. These are objects that receive and execute commands}
}
\newglossaryentry{vkrenderingattachmentinfo}
{
name={vkRenderingAttachmentInfoKHR},
description={KHR means khronos, which means we are using some kind of
  extension. This specific extension is for dynamic rendering, so we
won't use vkRenderPass objects directly?}
}
\newglossaryentry{queuefamilyindex}
{
name={Queue Family Index},
description={How we access a GPU queue family}
}
\newglossaryentry{colorattachment}
{
name={Color Attachment},
description={idk}
}
\newglossaryentry{stencilattachment}
{
name={Stencil Attachment},
description={idk}
}
\newglossaryentry{rendertargetviews}
{
name={Render Target Views},
description={idk, maybe this is the view we are currently using to
write to the image?}
}
\newglossaryentry{resourcebarriers}
{
name={Resource Barriers},
description={idk}
}
\newglossaryentry{mipmap}
{
name={Mip Map},
description={A \textbf{mip map} is something that we generate and
  give to Vulkan. A mip map is how we store a texture with different
  sizes (factors of 2), so that when the texture is far away Vulkan
will sample a lower-resolution texture}
}
\newglossaryentry{Graphics Queue}
{
name={Graphics Queue},
description={Draws stuff}
}
\newglossaryentry{Compute Queue}
{
name={Compute Queue},
description={For example, could do math}
}
\newglossaryentry{Transfer Queue}
{
name={Transfer Queue},
description={Good for copying data}
}
\newglossaryentry{label}
{
name={label},
description={Description}
}
\newglossaryentry{SV Position}
{
name={SV Position},
description={idk}
}
\newglossaryentry{SV Point Size}
{
name={SV Point Size},
description={idk}
}
\newglossaryentry{vk::binding}
{
name={vk::binding},
description={idk}
}
\newglossaryentry{Sampler2D}
{
name={Sampler2D},
description={idk}
}
\newglossaryentry{RW Structured Buffer}
{
name={RW Structured Buffer},
description={idk}
}
\newglossaryentry{Damped Dot}
{
name={Damped Dot},
description={idk}
}
\newglossaryentry{Gradient Position}
{
name={Gradient Position},
description={idk}
}
\newglossaryentry{Push Constants}
{
name={Push Constants},
description={idk}
}
\newglossaryentry{Global Invocation ID}
{
name={Global Invocation ID},
description={idk, I think this relates to thread managment}
}
\newglossaryentry{Dispatch Thread}
{
name={Dispatch Thread},
description={idk}
}
\newglossaryentry{SV Dispatch Thread ID}
{
name={SV Dispatch Thread ID},
description={idk}
}
\newglossaryentry{Staging Buffer}
{
name={Staging Buffer},
description={Memory from CPU to GPU must go to a \textbf{staging
buffer} first}
}
\newglossaryentry{KHR}
{
name={KHR},
description={Khronos or Khronos Group\textemdash can relate to offical
extension (what is extension)}
}
\newglossaryentry{VkQueueFamilyProperties}
{
name={VkQueueFamilyProperties},
description={What properties can a queue family have?}
}
\newglossaryentry{Dependancy Injection}
{
name={Dependancy Injection},
description={idk, is this related to dynamically linked libraries(DLL)?}
}
\newglossaryentry{Const Correctness}
{
name={Const Correctness},
description={\textbf{const correctness} is the idea of making
  a variable read-only in certain program scopes, not allowing for
unwanted writes. This is a key feature of C++ keyword \textbf{const}}
}
\newglossaryentry{sType}
{
name={sType},
description={\textbf{sType} is short for structure type, but why is
  it important? I guess this relates to how the driver (the GPU
  driver?) needs to understand the Vulkan program. So sType says to
the driver: "The next struct (pNext?) is an image, buffer, or pipeline"}
}
\newglossaryentry{Object Slicing}
{
name={Object Slicing},
description={idk, it is an idea with inheritance in cpp and copying
objects by value}
}
\newglossaryentry{Blending}
{
name={Blending},
description={Blending refers to creating a transparency
  effect. For example, you might use blending so that a UI is
transparent so you can see the game scene behind it}
}
\newglossaryentry{VkPipelineColorBlendStateCreateInfo}
{
name={VkPipelineColorBlendStateCreateInfo},
description={Description}
}
\newglossaryentry{VkPipelineColorBlendStateCreateInfo}
{
name={VkPipelineColorBlendStateCreateInfo},
description={This is used to implement transparency, but why?? What
  is CreateInfo again? CreateInfo relate to structs that store Vulkan
state info right?}
}
\newglossaryentry{pNext Chain}
{
name={pNext Chain},
description={Vulkan has a chain of extensions that require this?
Also this is related to pNext?}
}
\newglossaryentry{extension chain}
{
name={extension chain},
description={idk what this is + relates to stype and pnext??}
}
\newglossaryentry{vkStructure}
{
name={vkStructure},
description={What is a \textbf{vkStructure}? How does Sascha
Willems save us from assignments with the \textbf{vks} namespace?}
}
\newglossaryentry{Inline}
{
name={inlin},
description={What does keyword \textbf{inline} do in C++? Is it
common? Is it important for performant code?}
}
\newglossaryentry{VkSurfaceKHR}
{
name={VkSurfaceKHR},
description={idk, it has something to do with the image pipeline. So
there is something called a surface? How does this relate to Vulkan pipeline?}
}
\newglossaryentry{vkShaderModule}
{
name={vkShaderModule},
description={idk}
}
\newglossaryentry{vkMemAllocInfo}
{
name={vkMemAllocInfo},
description={idk}
}
\newglossaryentry{vkBuffer}
{
name={vkBuffer},
description={idk, I mean I guess it is the primitive buffer object
  that we allocate in Vulkan? Can we initialize a vkBuffer with the
vks::vkBuffer type? how do we populate a buffer?}
}
\newglossaryentry{Extension}
{
name={Extension},
description={Khronos uses \textbf{extensions} to officially add
functionality to the Vulkan specification?}
}
\newglossaryentry{vkMapMemory}
{
name={vkMapMemory},
description={idk}
}
\newglossaryentry{vkUnmapMemory}
{
name={vkUnmapMemory},
description={This is basically a cleanup function that we should call
after we use vkMapMemory}
}
\newglossaryentry{vkCmdBeginRenderPass}
{
name={vkCmdBeginRenderPass},
description={idk}
}
\newglossaryentry{vkCmdBindPipeline}
{
name={vkCmdBindPipeline},
description={idk}
}
\newglossaryentry{vkCmdDraw}
{
name={vkCmdDraw},
description={Description}
}
\newglossaryentry{vkQueueSubmit}
{
name={vkQueueSubmit},
description={idk, submit commands to queue? or submit queue (but
this doesn't make sense)}
}
\newglossaryentry{vkPipelineCache}
{
name={vkPipelineCache},
description={idk, why are we caching the pipeline?}
}
\newglossaryentry{prepareStorageBuffers}
{
name={prepareStorageBuffers()},
description={This is the step where we prepare the buffers to be
sent from the CPU to the GPU}
}
\newglossaryentry{stagingBuffer}
{
name={stagingBuffer},
description={where we put memory to be sent to the GPU}
}
\newglossaryentry{Resource}
{
name={Resource},
description={A \textbf{resource} can be for example a texture (I don't know
  what else), and it can hold many \textbf{subresources}. So it is
  usually thought of as a collection of subresources. An example is how
  a mesh in a game has many 'texures'. Like a roughness map, depth
texture etc. The roughness map would be considered a subresource.}
}
\newglossaryentry{Decouple}
{
name={Decouple},
description={When two systems can communicate without knowing the
state of each other}
}
\newglossaryentry{SSBO}
{
name={Shader Storage Buffer Object (SSBO)},
description={idk, this is involved with staging buffers?}
}
\newglossaryentry{Tessellation Shader}
{
name={Tessellation Shader},
description={Can subdivide geometry output from vertex shader}
}
\newglossaryentry{Vertex Shader}
{
name={Vertex Shader},
description={Determines where vertices should be drawn on the screen}
}
\newglossaryentry{Fragment Shader}
{
name={Fragment Shader},
description={Determines color of pixels?}
}
\newglossaryentry{Geometry Shader}
{
name={Geometry Shader},
description={idk}
}
\newglossaryentry{Rasterization}
{
name={Rasterization},
description={When we draw to the screen?? idk}
}
\newglossaryentry{Input Assembly}
{
name={Input Assembly},
description={Some part of the Vulkan pipeline, but what does it do?
Is it at the beginning?}
}

% END GLOS

\printglossaries
\addcontentsline{toc}{section}{Glossary}
\clearpage

\section*{To-Do (For This
Document)}\addcontentsline{toc}{section}{To-Do (For This
Document)}
\par I think this might be a nice place to keep my thoughts about
this document in an organized manner.

\clearpage
\section*{Appendix}
\addcontentsline{toc}{section}{Appendix}
\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.95\textwidth]{figures/vulkanpipeline.png}
\end{center}
\caption{Vulkan Pipeline}\label{fig:}
\end{figure}

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.95\textwidth]{figures/vulkanpipeline2.png}
\end{center}
\caption{Vulkan Pipeline Again}\label{fig:}
\end{figure}

% END APPENDIX
\end{document}
