\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{{figures/}}  % then \includegraphics{createmode_0.jpg}
% for color box
\usepackage{tcolorbox}
\tcbuselibrary{listings, skins, breakable}
% math
\usepackage{amsmath, amssymb, amsthm}
% for float formatting options
\usepackage{float}
% tikz
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, fit}
% for tikz formatting
\usepackage{adjustbox}
% for links
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=magenta,
citecolor=violet]{hyperref}
% for glossary
\usepackage[nonumberlist]{glossaries}
\makeglossaries

\title{Vulkan Notes}
\author{Joseph Grimsic}
\date{November 2025}
\usepackage[letterpaper, top=1.3in, bottom=1.3in, left=1.3in,
right=1.3in, heightrounded]{geometry}
\renewcommand{\baselinestretch}{1.15} % Line spacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.8em}
\begin{document}
\maketitle

% --- This is the magic command ---
\tableofcontents

\newpage % Starts the main content on a new page

\section*{Vulkan Questions}
\addcontentsline{toc}{section}{Vulkan Questions}
\begin{itemize}
  \item what are the things that specifically separates OpenGL and Vulkan?
  \item What is sType?
  \item What is a command pool?
  \item How can we abstract commands/ should we?
  \item Do we need to work with commands regularly to parallelize our
    game engine?
\end{itemize}

\section*{What If I Use Sascha as a starting point}
\addcontentsline{toc}{section}{What If I Use Sascha as a starting point}
\begin{itemize}
  \item How would I work with or change this program to write a game engine?
  \item What abstractions would I want to make?
  \item What if I am a solo devâ€”does that change how I should abstract things?
  \item How can I black box the lesser parts of Vulkan I don't need
    to know that deeply?
  \item What levels of abstraction will I usually be using?
\end{itemize}

\section*{Vulkan Resources}
\addcontentsline{toc}{section}{Vulkan Resources}
\begin{itemize}
  \item
    \href{https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp}{Vulkan
    Triangle Example}
  \item \href{https://github.com/KhronosGroup/Vulkan-Hpp}{Vulkan Helper?}

  \item
    \href{https://www.reddit.com/r/GraphicsProgramming/comments/tc9d2u/the_current_state_of_gpu_apis_and_why_i_wish_vez/}{Interesting
    opinions on Vulkan}

  \item
    \href{https://docs.vulkan.org/tutorial/latest/00_Introduction.html}{Vulkan
    Tutorial By Khronos Group}
  \item \href{https://vkguide.dev/}{vkguide.dev}
\end{itemize}

\section*{Sascha Willems Helpers}
\addcontentsline{toc}{section}{Sascha Willems Helpers}
\subsection*{\_CreateInfo and \_Info}
\addcontentsline{toc}{subsection}{\_CreateInfo and \_Info}
I don't know what Sascha's functions are entirely for\textemdash
except that they attempt to reduce Vulkan boilerplate. However, it
seems that every function returns two kinds of pointers:
\begin{verbatim}
*_CreateInfo
*_Info
\end{verbatim}
\par We are using some kind of struct\textemdash but I'm not sure what the
struct is for. The struct probably holds whatever these two kinds of
pointers point to?

\par So actually, the \* in \*\_CreateInfo and
\*\_Info represent the wildcard operator, and is just to show
the naming convention in the documentation. These names refer to
structs that have state information for Vulkan.

\subsection*{Commands}
\addcontentsline{toc}{subsection}{Commands}
\par Commands are the main part of Vulkan. Commands are how we talk
directly to the GPU.

\par Commands are normally stored in a \textbf{command buffer}, so we
can batch them together. We usually call the act of intializing a
command buffer \textbf{recording} the command buffer. In the Vulkan
workflow, we will have record a command buffer using a
\textbf{command pool}. We will have one command pool for every
\textbf{queue family}.

\section*{Sascha Repository Notes}
\addcontentsline{toc}{section}{Sascha Repository Notes}
\par Git does not automatically download submodules

\par To update submodules:
\begin{verbatim}
git submodule update --init --recursive
\end{verbatim}

\par The following is an example clean build script specific to Wayland:

\begin{verbatim}
#!/usr/bin/env bash
set -e

BUILD_DIR="build"

echo ">>> Removing old build directory..."
rm -rf "$BUILD_DIR"

echo ">>> Creating new build directory..."
mkdir "$BUILD_DIR"
cd "$BUILD_DIR"

echo ">>> Running CMake configure..."
cmake .. \
  -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
  -DUSE_WAYLAND_WSI=OFF

echo ">>> Building..."
cmake --build . -- -j"$(nproc)"

# Optionally copy compile_commands.json to project root
if [ -f compile_commands.json ]; then
    echo ">>> Copying compile_commands.json to project root..."
    cp compile_commands.json ..
fi

echo ">>> Done."
\end{verbatim}

Then you can run the binaries, for example:
\begin{verbatim}
./build/bin/bloom
\end{verbatim}

\section*{Reading Through The Vulkan Tutorial}
\addcontentsline{toc}{section}{Reading Through The Vulkan Tutorial}
Here is a high level of how I would currently describe the Vulkan setup:

\begin{enumerate}
  \item create instance
  \item device selection
  \item create window
  \item then some other stuff
\end{enumerate}

here is my second attempt at that
\begin{enumerate}
  \item create instance + device selection
  \item queue families stuff
  \item create window + swapchain
  \item framebuffer stuff
  \item probably something else
\end{enumerate}

\par we are getting closer, but honestly maybe it's not that important. i
am considering reading throught the Vulkan tutorial but i am unsure
as when to just jump in. i could probably save some time in the
future by reading a little bit now but i suspect i will not retain
that much information. i guess i will take some notes.
\par first i will skip to the hello triangle in their example and think of
some questions i have..
\par some things that stand out to me:
\begin{itemize}
  \item item (will i finish?)
\end{itemize}

\section*{Going Through Sascha's Repository}
\addcontentsline{toc}{section}{Going Through Sascha's Repository}
\subsection*{Idea}
\addcontentsline{toc}{subsection}{Idea}
I am thinking this will be faster to learn as Sascha provides a
standard hello triangle program (meant to be as vanilla as possible)
and shows his evolution (you can see comments in his READ.md) of
abstractions. This will likely make the most sense to study because
we know that Sascha has a
\href{https://github.com/SaschaWillems/Vulkan?tab=readme-ov-file}{very
popular repo} so we can assume others think it is good and that it is
a valid idea for me to pursue.

\subsection*{Notes On Sascha}
\addcontentsline{toc}{subsection}{Notes On Sascha}
\par Let's start with is Sascha's claimed vanilla hello triangle similar
to the one in the Khronos Vulkan tutorial?

\subsection*{Questions From Sascha's Repo:}
\addcontentsline{toc}{subsection}{Questions From Sascha's Repo:}
\begin{itemize}
    % \item what is a descriptor set in vulkan?
  \item what is the graphics queue?
    % \item what is a vk semaphore?
    % \item what is vk device?
    % \item what is vk null handle?
    % \item what is vk descriptor set?
  \item what is vk pipeline layout?
  \item how to read/write to a glm::mat4?
    % \item what is vk descriptor set layout?
  \item how do we interact with vk command pool?
  \item what does this do?
  \begin{verbatim}
  VulkanExample() : VulkanExampleBase() {
  \end{verbatim}

\end{itemize}

\section*{Theory}
\addcontentsline{toc}{section}{Theory}
\subsection*{Descriptor Set}
\addcontentsline{toc}{subsection}{Descriptor Set}
\par Descriptor sets are sets of pointers to resources that shaders
want access to. In OpenGL, you might 'bind' one buffer at a time.
Vulkan expects you to bind a descriptor set all together.
\par Similar to \textbf{command pools} there are \textbf{descriptor pools}.

\subsection*{Descriptor Pools}
\addcontentsline{toc}{subsection}{Descriptor Pools}
\par To allocate a descriptor set, we first intialize a descriptor
pool. When setting up a descriptor pool, we tell Vulkan there will be
'x' number of sets with 'y' number of descriptors

\subsection*{Fences}
\addcontentsline{toc}{subsection}{Fences}
\par A fence is used to sync the CPU and GPU. I don't know how it
does this. A fence can be \textbf{signaled} by the GPU, so that the
CPU knows that the GPU has finished drawing the frame.

\subsection*{Semaphore}
\addcontentsline{toc}{subsection}{Semaphore}
\par Similarly, a \textbf{semaphore} is used to sync different parts
of the GPU. Some examples of semaphores are:
\begin{itemize}
  \item \textbf{renderSemaphore}
  \item \textbf{swapchainSemaphore}
\end{itemize}
\par There is also a \textbf{complete semaphore}, but I don't know
what that is for yet.

\subsection*{Projection Matrix}
\addcontentsline{toc}{subsection}{Projection Matrix}
\par This has something to do with how objects look when they are
further away, maybe it does some multiplication on the location of
the vertices on screen coordinates?

\par This is close. It has to do with a matrix multiplication on the
3d vertices of an object, altering how it looks from far away. The
projection matrix is part of the pipeline to get objects in 3d space
to screen space coordinates.

\par Note: The lack of a projection matrix is called an orthographic projection.

\subsection*{View Model Matrix}
\addcontentsline{toc}{subsection}{View Model Matrix}
\par This has something to do with the view frustum? Perhaps this is
the matrix that we perform operations on to change the camera
position and angle?

\subsection*{Depth Stencil Image}
\addcontentsline{toc}{subsection}{Depth Stencil Image}
\par What is the depth stencil image? I mean stencils are like
outlines of stuff so maybe depth stencil image draws the outlines of
objects in the depth frame buffer? Is the Z buffer a separate frame buffer?

\par So a depth stencil image is actually a combination of buffers
(both the depth and stencil buffers).

\subsection*{Stencil Buffer}
\addcontentsline{toc}{subsection}{Stencil Buffer}
\par Let's review what a stencil buffer is. It is true that a stencil
buffer can be used for outlines, but more generally\textemdash
stencil buffers can be thought of as masks. The concept of masking is
where you can think of separating layers. So you may 'cutout' a layer
by masking, so that you can see to the next layer.

\par Another way to think of this as a subtractive process. Here is
an excerpt from a conversation with Gemini 2.5 Pro:
\begin{verbatim}
Pass 1: Draw the Object (to create the "cutout" mask).
        Turn off writing to the color and depth buffers.
        Turn on writing to the stencil buffer.
        Set the stencil operation to: "If a pixel passes the depth test,
        write the value 1 into the stencil buffer."
        Draw your mesh.

        Result: The screen looks unchanged, but the stencil buffer now
        contains a perfect silhouette (a "mask") of your object, filled
        with the number 1. Everything else is 0.

    Pass 2: Draw the Outline (the "big yellow" version).
        Turn on writing to the color buffer (so we can see the yellow).
        Turn off writing to the depth buffer (this prevents the outline
        from messing up future depth tests).
        Set the stencil test to: "Only draw a pixel if the stencil buffer value
        at that location is NOT 1 (i.e., it's 0)."
        Draw a slightly larger version of your mesh, all in yellow.

    The "Cutout" Happens:

        The GPU starts to draw the big yellow mesh.
        Where the original object was (the "inner layer"), the stencil buffer
        has a 1. The test (stencil_value != 1) fails, and the yellow pixel is
        discarded. This is your "cutout"!

        On the larger edges of the yellow mesh (the "thickness" you mentioned), the pixel falls outside the original silhouette. The stencil buffer there is 0. The test (stencil_value == 0) passes, and the yellow pixel is drawn.

Final Result: You are left with only the yellow outline.
\end{verbatim}

\subsection*{Reading Code Snippet And Some Resulting Questions}
\addcontentsline{toc}{subsection}{Reading Code Snippet And Some
Resulting Questions}

\par When reading through Sascha's examples I came across this segment from
triangle.cpp:

\begin{verbatim}
// Create a view for the depth stencil image
// Images aren't directly accessed in Vulkan, but rather through views
// described by a subresource range This allows for multiple views of one
// image with differing ranges (e.g. for different layers)
VkImageViewCreateInfo depthStencilViewCI{};
depthStencilViewCI.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
depthStencilViewCI.viewType = VK_IMAGE_VIEW_TYPE_2D;
depthStencilViewCI.format = depthFormat;
depthStencilViewCI.subresourceRange = {};
depthStencilViewCI.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
\end{verbatim}

\par What is a view? It seems that we first initialize the view and
then there are several instance variables we set for it. This code
snippet reveals many different questions:
\begin{itemize}
  \item What is a \textbf{subresource}?
  \item What is an \textbf{aspect}?
  \item What what does '\textbf{CI}' mean in 'depthStencilViewCI'?
\end{itemize}

\par I also have some more questions as a result from this snippet:
\begin{itemize}
  \item What kinds of things do we need a view for?
  \item Does Sascha abstract some of this 'state stuff' away when
    intializing a view?
  \item What does an all caps variable like
    'VK\_STRUCTURE\_TYPE\_IMAGE\_VIEW\_CREATE\_INFO'| mean again? Is it a
    global constant?
  \item \textemdash and finally, how much of this is important to me
    as an engine developer?
\end{itemize}

\subsection*{What Does 'CI' Suffix Mean In Variable Names?}
\addcontentsline{toc}{subsection}{What Does 'CI' Suffix Mean In Variable Names?}
\par CI is actually shorthand for \textbf{Create Info}. This is
because this variable is a \textbf{CreateInfo struct}, same as we
mentioned earlier.

\subsection*{VK View}
\addcontentsline{toc}{subsection}{VK View}
\par Images cannot be directly accessed in Vulkan, but instead with a
View object. Hence the two Vulkan objects:
\begin{itemize}
  \item VkImage
  \item VkImageView
\end{itemize}

\subsection*{How Does A View Relate To A Frame Buffer?}
\addcontentsline{toc}{subsection}{How Does A View Relate To A Frame Buffer?}
\par A frame buffer has views as attachments?

\par A \textbf{VkImage} is a collection of the image's raw data and
overall properties such as:
\begin{itemize}
  \item Dimension
  \item Format
  \item Mip Levels
\end{itemize}

\subsection*{Subresource}
\addcontentsline{toc}{subsection}{Subresource}
\par What is a subresource and how can it have a range?

\subsection*{VK\_NULL\_HANDLE}
\addcontentsline{toc}{subsection}{VK\_NULL\_HANDLE}
\par Weirdly, the VK\_NULL\_HANDLE is an integer, and not a null
pointer or something like that. We use VK\_NULL\_HANDLE| when we
are declaring some Vulkan object without giving it a value.

\subsection*{Ticket Number}
\addcontentsline{toc}{subsection}{Ticket Number}
What is a \textbf{ticket number}? What does it mean if there is an
\textbf{empty ticket number}? What is a \textbf{ticket slot}, and
what does it mean for it to be empty (0)?

\subsection*{How is initialization abstracted with Sascha's Framework?}
\addcontentsline{toc}{subsection}{How is initialization abstracted
with Sascha's Framework?}

\par The following is a snippet from a conversation with Gemini 2.5 Pro:
\begin{verbatim}
Before: Raw Vulkan (What we discussed)

You have to manually zero-initialize every struct and set every single
member, including the sType.

// 1. Define the binding
VkDescriptorSetLayoutBinding uboBinding{};
uboBinding.sType = ... // Easy to forget! Oh wait, this one doesn't have sType.
uboBinding.binding = 0;
uboBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
uboBinding.descriptorCount = 1;
uboBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
uboBinding.pImmutableSamplers = nullptr;

// 2. Define the create info
VkDescriptorSetLayoutCreateInfo layoutInfo{};
layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
layoutInfo.pNext = nullptr;
layoutInfo.flags = 0;
layoutInfo.bindingCount = 1;
layoutInfo.pBindings = &uboBinding;

After: With Sascha Willems' vks::initializers

He provides helper functions that act as "constructors" for these C structs.
They take the important parameters and set all the other members (sType, pNext,
flags, etc.) to correct default values.

// 1. Define the binding (one line)
VkDescriptorSetLayoutBinding uboBinding =
    vks::initializers::descriptorSetLayoutBinding(
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        VK_SHADER_STAGE_VERTEX_BIT,
        0); // type, stage, binding

// 2. Define the create info (one line)
VkDescriptorSetLayoutCreateInfo layoutInfo =
    vks::initializers::descriptorSetLayoutCreateInfo(
        &uboBinding,
        1); // pBindings, bindingCount
\end{verbatim}
This example may prove useful when learning Sascha's framework.

\subsection*{What is multisampling (MSAA?)}
\addcontentsline{toc}{subsection}{What is multisampling (MSAA?)}
\par Multisampling (MSAA) is a method of anti aliasing. Aliasing happens
when a single sample inside of the pixel does not detect the
sub\-pixel fragment, so the result of the pixel can become an
artifact. Sub\-pixel artifacting are called \textbf{jaggies}, which
are a result of aliasing. To address this issue, we have multiple
sub\-pixel samples\textemdash hence the name.

\subsection*{Device vs. Physical Device}
\addcontentsline{toc}{subsection}{Device vs. Physical Device}
\par In Vulkan, there are two kinds of devices:
\begin{itemize}
  \item The \textbf{physical device (VkPhysicalDevice)}
  \item And the \textbf{logical device (VkDevice)}
\end{itemize}
\par Most always in the context of Vulkan, we are talking about the
logical device. The logical device is the object that you use to
interface with the hardware. You initialize VkDevice with the
tools/features that you are going to be using from the GPU.

% Begin large gemini latex segment
\subsection*{High-level pseudocode: Basic indexed triangle (Vulkan 1.3)}
\addcontentsline{toc}{subsection}{High-level pseudocode: Basic
indexed triangle (Vulkan 1.3)}

This example initializes a minimal Vulkan application that renders a
single indexed triangle using Vulkan 1.3 dynamic rendering and
per-frame uniform buffers.

\begin{enumerate}
  \item Create the application object and parse command-line
    arguments. Configure a simple look-at camera and request Vulkan
    API version \texttt{VK\_API\_VERSION\_1\_3}, enabling the
    \texttt{dynamicRendering} and \texttt{synchronization2} features.
  \item Initialize Vulkan: create an instance, select a compatible
    physical device, create a logical device and graphics queue, and
    cache device properties and memory capabilities for later allocations.
  \item Prepare global state and resources used across frames:
    determine swapchain color/depth formats and reserve per-frame
    arrays sized by \texttt{MAX\_CONCURRENT\_FRAMES} for in-flight resources.
  \item Create synchronization primitives: one fence per in-flight
    frame (initially signaled) and semaphores to coordinate image
    acquisition and render completion.
  \item Create one command pool and allocate one primary command
    buffer per in-flight frame.
  \item Build vertex and index data for a triangle; compute buffer
    sizes and the index count.
  \item Create a host-visible staging buffer, map it, and copy both
    vertex and index data into that single mapped region.
  \item Create device-local vertex and index buffers (with transfer
    destination usage), allocate device-local memory for each, and bind them.
  \item Record and submit a short command buffer that copies the
    ranges from the staging buffer into the device-local buffers; use
    a temporary fence to wait for completion, then free the staging buffer.
  \item Define a uniform block type containing projection, view and
    model matrices and create one host-visible, coherent uniform
    buffer per in-flight frame; map them persistently for fast updates.
  \item Create a descriptor pool and a descriptor set layout for a
    single uniform buffer binding; allocate and update one descriptor
    set per in-flight frame to point at the corresponding uniform buffer.
  \item Create a pipeline layout using the descriptor set layout,
    then build the graphics pipeline: load SPIR-V shaders, configure
    vertex input bindings/attributes, input assembly, rasterization,
    depth/stencil, multisampling, color blend and dynamic
    viewport/scissor, and attach dynamic rendering formats.
  \item Allocate and bind a device-local depth image and create an
    image view for depth/stencil usage.
  \item In the render loop: wait on the current frame fence, acquire
    the next swapchain image (handling out-of-date/suboptimal by
    resizing), update the mapped uniform buffer for the current
    frame, reset and begin the command buffer.
  \item Insert image memory barriers to transition color and depth
    images to attachment-optimal layouts, begin a dynamic rendering
    section, set viewport and scissor dynamically, bind pipeline and
    the current frame's descriptor set, bind vertex and index
    buffers, and issue a single indexed draw call; end rendering and
    transition the color image to present layout.
  \item Submit the command buffer waiting on the present semaphore
    and signaling a render-complete semaphore; pass the per-frame
    fence for GPU completion tracking. Present the image using
    \texttt{vkQueuePresentKHR}, handling resizing if necessary, and
    advance the current frame index modulo \texttt{MAX\_CONCURRENT\_FRAMES}.
  \item On shutdown, wait for device idle and clean up: destroy
    pipelines, pipeline layout, descriptor set layout and pool,
    buffers and their memories, image views and images, semaphores,
    fences, command pool and swapchain resources; delete the application object.
\end{enumerate}

\par \textbf{One thing to note}:

\par After looking at the example \textbf{Raytracing Reflections}, I
noticed that there are only 500 lines of code, and the output is a
fully rendered scene with some reflections. This sort of thing gives
me hope because the complexity was seeming cut in half (compared to
900 lines for a triangle). This seems like a decent starting point
for a scene. There are still lots of points of confusion\textemdash
even some that are purely about C++ for example the \textbf{::}
operator not only being used for namespaces.
% End large gemini latex segment

\subsection*{Families and
Queues}\addcontentsline{toc}{subsection}{Families and Queues}

\par When a Vulkan instance is created, one of the things it does
before anything is rendered to the screen, is query the system's GPU
(vkPhysicalDevice). The physical device will tell us important
information; for example, the index of the compute family. This is
because different GPU's have different index values for families.

\paragraph*{Families}\addcontentsline{toc}{paragraph}{Families}

A family is a group of \textbf{queues}. For example, there is the
\textbf{graphics family}, which has one or more \textbf{graphics
queue} objects that interface with the rendering hardware.

\paragraph*{Graphics Queue}\addcontentsline{toc}{paragraph}{Graphics Queue}

The \textbf{graphics queue} is an object that you would send commands
to. The graphics queue is responsible for the rendering, as opposed
to the \textbf{compute queue}, which you might use for gameplay math.

\paragraph*{Compute Queue}\addcontentsline{toc}{paragraph}{Compute Queue}

But actually it is not just for 'gameplay math', but instead highly
parallelizable math. Some examples are the folllwing:
\begin{itemize}
  \item Physics Simulations
  \item Post Processing (Not apart of the graphics queue!?!)
  \item Culling!?
\end{itemize}

\paragraph*{Transfer Queue}\addcontentsline{toc}{paragraph}{Transfer Queue}

\paragraph*{Transfer Queue}
The \textbf{transfer queue} is specialized for high-speed DMA (Direct
Memory Access) transfers. We use this queue to move data from
CPU-visible \textbf{staging buffers} into high-performance GPU
memory. This includes bulk data such as textures, vertex buffers, and
index buffers. By offloading these copy operations to the transfer
queue, the graphics queue remains free to focus entirely on
rendering, allowing for asynchronous execution.

\paragraph*{What Are Queues
For?}\addcontentsline{toc}{paragraph}{What Are Queues For?}

Queues are objects that receive \textbf{commands}. The central idea behind
Vulkan is that the GPU receives \textbf{command buffers} from the CPU
program, and the GPU (physical device) executes said commands.

\paragraph*{Why Not Submit All Tasks To One Of The
Families?}\addcontentsline{toc}{paragraph}{Why Not Submit All Tasks
To One Of The Families?}

We seperate graphics family tasks and compute family tasks because
say we were to put everything on the graphics queue; then, we would
not be able to compute our graphics tasks in parallel with our compute tasks.

\subsection*{Slang}\addcontentsline{toc}{subsection}{Slang}

\par After looking at a Slang shader file, I notice things like there
are global functions for dot() and sqrt(). What other global
functions are there? What are some main concepts behind writing shaders?

\par Here is an example of collision detection in Slang:
\begin{verbatim}
    // collide with boundary
    if ((vPos.x < -1.0) || (vPos.x > 1.0) || (vPos.y < -1.0) || (vPos.y > 1.0)) {
        vVel = (-vVel * 0.1) + attraction(vPos, destPos) * 12;
    } else {
        particlesOut[index].pos.xy = vPos;
    }
\end{verbatim}

\par What is this following segment for?
\begin{verbatim}
    // Write back
    particlesOut[index].vel.xy = vVel;
    particlesOut[index].gradientPos.x = gPos.x + 0.02 * ubo.deltaT;
    if (particlesOut[index].gradientPos.x > 1.0) {
        particlesOut[index].gradientPos.x -= 1.0;
    }
\end{verbatim}

\clearpage

\section*{C++ Notes}
\addcontentsline{toc}{section}{C++ Notes}

\subsection*{Struct vs. Class}
\addcontentsline{toc}{subsection}{Struct vs. Class}
\par One thing that vkguide.dev has brought to my attention is when
to use struct versus when to use a class. From my understanding, a
struct is used for simple instances when we just need to store a
group of data. A class can hold lots of things for example state,
functionality, and data too.

\subsection*{Constructor Definition Syntax}
\addcontentsline{toc}{subsection}{Constructor Definition Syntax}
\par The following is a way to declare a new constructor:

\begin{verbatim}
VulkanExample() : VulkanExampleBase() {}
\end{verbatim}

\par More generally, it is written as:
\begin{verbatim}
constructorFromDerivedClass?() : NewConstructor?()
\end{verbatim}

\par I am very confused\textemdash but maybe it is unimportant

\subsection*{How To Make A Class}
\addcontentsline{toc}{subsection}{How To Make A Class}
\par In C++, to make a class we usually do the following:
\begin{enumerate}
  \item Declare the class in a header (e.g. class.h)
  \item Implement the class functionality in a source file (e.g. class.cpp)
\end{enumerate}

\subsection*{How To Make A Struct}
\par Weirdly, in C++ structs do not need keyword \textbf{typedef}
when declared..

\subsection*{How To Make A Template Class?}
\addcontentsline{toc}{subsection}{How To Make A Template Class?}
\par A template has to do with implementing functionality across
different primitive types? Like overloading function sum so that
sum(int a, int b) and sum(double a, double b)? What makes templates
different than classes? Do we use headers for them too?

\subsection*{:: Operator}
\addcontentsline{toc}{subsection}{:: Operator}
\par I was previously aware that the \textbf{::} operator could be
used to access members of a namespace\textemdash but now I am finding
out that it can be used to call specific functions in an inheritance
hierarchy. How does this work?

\par Update: The \textbf{::} operator is called the \textbf{scope
resolution modifier}. The scope resolution modifier is not only used
for namespace members, but another example is an enum class. Say you
have an enum class defined with the following:
\begin{verbatim}
enum class ShadowQuality{
kNone,
kLow,
kMedium,
kHigh,
}
\end{verbatim}

\subsection*{Const Correctness}
\par I don't fully understand the idea of \textbf{const
correctness}\textemdash but so far it seems like the idea of a
read-only member variable. The current working example I am
considering is the following:

\par We want our game engine to allow the user to choose settings
based on the power of their machine. For example, the user may want
to lower quality of shadows, so we can set shadows to the following states:
\begin{itemize}
  \item High Quality
  \item Medium Quality
  \item Low Quality
  \item None
\end{itemize}

\par We can store this data in a struct:
\begin{verbatim}
struct {
int shadow_quality
} typedef GameConfig
\end{verbatim}

\section*{What Is A Valid Starting Point For My Game Engine?}
\addcontentsline{toc}{section}{What Is A Valid Starting Point For My
Game Engine?}

\par I am currently considering the example from Sascha Willems
called \textbf{Raytracing Reflections}.

\clearpage

\glsaddall
% --- Vulkan Glossary Definitions ---

\newglossaryentry{spirv}
{
  name={SPIR-V},
  description={GLSL, HLSL, and Slang can all be compiled to SPIR-V,
  which is passed to Vulkan program}
}
\newglossaryentry{slang}
{
  name={Slang},
  description={A shading language that benefits from having generics
  and interfaces that glsl doesn't have}
}
\newglossaryentry{semaphore}
{
  name={Semaphore},
  description={Object responsible for keeping different GPU cores synced}
}
\newglossaryentry{fence}
{
  name={Fence},
  description={Object responsible for keeping CPU and GPU synced}
}
\newglossaryentry{virtualfunction}
{
  name={Virtual Function},
  description={A C++ feature relating to polymorphism and inheritance
  of classes}
}
\newglossaryentry{sampling}
{
  name={Sampling},
  description={Query a subpixel value}
}
\newglossaryentry{aliasing}
{
  name={Aliasing},
  description={When \textbf{jaggies} misrepresent a pixel and cause discoloring}
}
\newglossaryentry{antialiasing}
{
  name={Anti Aliasing},
  description={Technique to combat \textbf{aliasing}, usually by some
  special way of sampling}
}
\newglossaryentry{msaa}
{
  name={Multisampling Antialiasing (MSAA)},
  description={An implementation of \textbf{anti aliasing}}
}
\newglossaryentry{ssaa}
{
  name={Super Sampling Antialiasing (SSAA)},
  description={An implementation of \textbf{anti aliasing},
  considered to be 'brute force'}
}
\newglossaryentry{sync2}
{
  name={Synchronization2},
  description={idk}
}
\newglossaryentry{dynamicrendering}
{
  name={Dynamic Rendering},
  description={This is the idea of removing the 'render pass' and
    'framebuffer' objects. In other words, we move the configuration
  from initialization to recording time}
}
\newglossaryentry{maxconcurrentframes}
{
  name={Max Concurrent Frames},
  description={Number of frames to be 'processed' simultaneously}
}
\newglossaryentry{memorybarriers}
{
  name={Memory Barriers},
  description={Used to make sure that one GPU core is finished
  writing to memory before another core tries to read}
}
\newglossaryentry{depthimage}
{
  name={Depth Image},
  description={idk}
}
\newglossaryentry{zbuffer}
{
  name={Z Buffer/ Depth Buffer},
  description={Used to determine if an object should be rendered
  in-front of another?}
}
\newglossaryentry{attachment}
{
  name={Attachment},
  description={idk, i think they are apart of frame buffers?}
}
\newglossaryentry{vkqueuepresent}
{
  name={Vk Queue Present KHR},
  description={The command that tells the OS to display the final image}
}
\newglossaryentry{deviceidle}
{
  name={Device Idle},
  description={Command to pause the CPU until the GPU is finished}
}
\newglossaryentry{applicationobject}
{
  name={Application Object},
  description={idk}
}
\newglossaryentry{vram}
{
  name={VRAM},
  description={Stores memory for GPU}
}
\newglossaryentry{devicelocal}
{
  name={Device-Local},
  description={Memory on the VRAM}
}
\newglossaryentry{swapchain}
{
  name={Swap Chain},
  description={A queue of rendered images waiting to be displayed}
}
\newglossaryentry{viewport}
{
  name={Viewport},
  description={The rectangular part of the window that is rendered
    to. For example you could have two viewports (top and bottom), for
  a split-screen multiplayer effect}
}
\newglossaryentry{inflightframe}
{
  name={In-Flight Frame},
  description={Idea of rendering current frame on GPU, and recording
  commands for next frame to be rendered, using CPU}
}
\newglossaryentry{rasterization}
{
  name={Rasterization},
  description={Part in graphics pipeline when we draw?}
}
\newglossaryentry{render}
{
  name={Render},
  description={The final output of the graphics pipeline?}
}
\newglossaryentry{attributes}
{
  name={Attributes},
  description={I think attributes are when we store data in vertices}
}
\newglossaryentry{commandpools}
{
  name={Command Pools},
  description={Object used to allocate command buffers}
}
\newglossaryentry{ticketnumber}
{
  name={Ticket Number},
  description={A timeline semaphore tracks completed tasks in
    strictly increasing number/sequence. A ticket number (a positive
    integer) is a certain complete task that we might wait for until we
  do something else}
}
\newglossaryentry{binarysemaphore}
{
  name={Binary Semaphore (Mutex)},
  description={Has two states(0 or 1), used to lock a resource, and
  managed by an owner}
}
\newglossaryentry{countingsemaphore}
{
  name={Counting Semaphore},
  description={Allows up to $N$ threads to access a resource simultanously}
}
\newglossaryentry{timelinesemaphore}
{
  name={Timeline Semaphore},
  description={Normal semaphore tracks complete or not
    complete\textemdash a \textbf{timeline semaphore} tracks more than
  1 complete steps in increasing order}
}
\newglossaryentry{subresource}
{
  name={Subresource},
  description={A part of an image}
}
\newglossaryentry{descriptorset}
{
  name={Descriptor Set},
  description={idk}
}
\newglossaryentry{descriptorpool}
{
  name={Descriptor Pool},
  description={Obviously some kind of object to allocate descriptors
  or descriptor sets?}
}
\newglossaryentry{device}
{
  name={Device},
  description={Like the object that keeps track of the rendering
  state of the Vulkan program?}
}
\newglossaryentry{instancedmesh}
{
  name={Instanced Mesh Rendering},
  description={Taking an instance/object and rendering it multiple
    times. For example a tree with many instances of leaves that have
  different rotations and size (Tell the GPU: "Draw this mesh 500 times")}
}
\newglossaryentry{pointrendering}
{
  name={Point Rendering},
  description={idk}
}
\newglossaryentry{queuefamily}
{
  name={Queue Family},
  description={Can refer to Graphics Queue, Compute Queue, or
  Transfer Queue. These are objects that receive and execute commands}
}
\newglossaryentry{vkrenderingattachmentinfo}
{
  name={vkRenderingAttachmentInfoKHR},
  description={idk, but KHR has to do with talking to OS to display
  output image}
}
\newglossaryentry{queuefamilyindex}
{
  name={Queue Family Index},
  description={How we access a GPU queue family}
}
\newglossaryentry{colorattachment}
{
  name={Color Attachment},
  description={idk}
}
\newglossaryentry{stencilattachment}
{
  name={Stencil Attachment},
  description={idk}
}
\newglossaryentry{rendertargetviews}
{
  name={Render Target Views},
  description={idk}
}
\newglossaryentry{resourcebarriers}
{
  name={Resource Barriers},
  description={idk}
}
\newglossaryentry{mip}
{
  name={Mip},
  description={idk}
}
\newglossaryentry{mipmap}
{
  name={Mip Map},
  description={idk, can relate to level of distance optimization? (LOD)}
}
\newglossaryentry{Graphics Queue}
{
  name={Graphics Queue},
  description={Draws stuff}
}
\newglossaryentry{Compute Queue}
{
  name={Compute Queue},
  description={For example, could do math}
}
\newglossaryentry{Transfer Queue}
{
  name={Transfer Queue},
  description={Good for copying data}
}
\newglossaryentry{label}
{
  name={label},
  description={Description}
}
\newglossaryentry{SV Position}
{
  name={SV Position},
  description={idk}
}
\newglossaryentry{SV Point Size}
{
  name={SV Point Size},
  description={idk}
}
\newglossaryentry{vk::binding}
{
  name={vk::binding},
  description={idk}
}
\newglossaryentry{Sampler2D}
{
  name={Sampler2D},
  description={idk}
}
\newglossaryentry{RW Structured Buffer}
{
  name={RW Structured Buffer},
  description={idk}
}
\newglossaryentry{Damped Dot}
{
  name={Damped Dot},
  description={idk}
}
\newglossaryentry{Gradient Position}
{
  name={Gradient Position},
  description={idk}
}
\newglossaryentry{Push Constants}
{
  name={Push Constants},
  description={idk}
}
\newglossaryentry{Global Invocation ID}
{
  name={Global Invocation ID},
  description={idk}
}
\newglossaryentry{Dispatch Thread}
{
  name={Dispatch Thread},
  description={idk}
}
\newglossaryentry{SV Dispatch Thread ID}
{
  name={SV Dispatch Thread ID},
  description={idk}
}
\newglossaryentry{Staging Buffer}
{
  name={Staging Buffer},
  description={Memory from CPU to GPU must go to a \textbf{staging
  buffer} first}
}
\newglossaryentry{KHR}
{
  name={KHR},
  description={Khronos or Khronos Group\textemdash can relate to offical
  extension (what is extension)}
}
\newglossaryentry{VkQueueFamilyProperties}
{
  name={VkQueueFamilyProperties},
  description={What properties can a queue family have?}
}
\newglossaryentry{Dependancy Injection}
{
  name={Dependancy Injection},
  description={idk}
}
\newglossaryentry{Const Correctness}
{
  name={Const Correctness},
  description={\textbf{const correctness} is the idea of making
    a variable read-only in certain program scopes, not allowing for
  unwanted writes. This is a key feature of C++ keyword \textbf{const}}
}
\newglossaryentry{sType}
{
  name={sType},
  description={idk}
}
\newglossaryentry{Object Slicing}
{
  name={Object Slicing},
  description={idk, it is an idea with inheritance in cpp and copying
  objects by value}
}

\printglossaries
\addcontentsline{toc}{section}{Glossary}
\clearpage

\section*{Appendix}
\addcontentsline{toc}{section}{Appendix}
\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.95\textwidth]{figures/vulkanpipeline.png}
  \end{center}
  \caption{Vulkan Pipeline (Why is it so low res :( )}\label{fig:}
  \end{figure}

  \begin{figure}[H]
    \begin{center}
      \includegraphics[width=0.95\textwidth]{figures/vulkanpipeline2.png}
    \end{center}
    \caption{Vulkan Pipeline (Why is it so low res :())}\label{fig:}
  \end{figure}

  \end{document}
